// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
	"wameter/internal/server/data/ent/agent"
	"wameter/internal/server/data/ent/ipchange"
	"wameter/internal/server/data/ent/metric"
	"wameter/internal/server/data/ent/predicate"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgent    = "Agent"
	TypeIPChange = "IPChange"
	TypeMetric   = "Metric"
)

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op            Op
	typ           string
	id            *string
	hostname      *string
	version       *string
	status        *string
	last_seen     *time.Time
	registered_at *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Agent, error)
	predicates    []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id string) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Agent entities.
func (m *AgentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHostname sets the "hostname" field.
func (m *AgentMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *AgentMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *AgentMutation) ResetHostname() {
	m.hostname = nil
}

// SetVersion sets the "version" field.
func (m *AgentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AgentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AgentMutation) ResetVersion() {
	m.version = nil
}

// SetStatus sets the "status" field.
func (m *AgentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AgentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AgentMutation) ResetStatus() {
	m.status = nil
}

// SetLastSeen sets the "last_seen" field.
func (m *AgentMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *AgentMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldLastSeen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *AgentMutation) ResetLastSeen() {
	m.last_seen = nil
}

// SetRegisteredAt sets the "registered_at" field.
func (m *AgentMutation) SetRegisteredAt(t time.Time) {
	m.registered_at = &t
}

// RegisteredAt returns the value of the "registered_at" field in the mutation.
func (m *AgentMutation) RegisteredAt() (r time.Time, exists bool) {
	v := m.registered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisteredAt returns the old "registered_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldRegisteredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisteredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisteredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisteredAt: %w", err)
	}
	return oldValue.RegisteredAt, nil
}

// ResetRegisteredAt resets all changes to the "registered_at" field.
func (m *AgentMutation) ResetRegisteredAt() {
	m.registered_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the AgentMutation builder.
func (m *AgentMutation) Where(ps ...predicate.Agent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Agent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.hostname != nil {
		fields = append(fields, agent.FieldHostname)
	}
	if m.version != nil {
		fields = append(fields, agent.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, agent.FieldStatus)
	}
	if m.last_seen != nil {
		fields = append(fields, agent.FieldLastSeen)
	}
	if m.registered_at != nil {
		fields = append(fields, agent.FieldRegisteredAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldHostname:
		return m.Hostname()
	case agent.FieldVersion:
		return m.Version()
	case agent.FieldStatus:
		return m.Status()
	case agent.FieldLastSeen:
		return m.LastSeen()
	case agent.FieldRegisteredAt:
		return m.RegisteredAt()
	case agent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldHostname:
		return m.OldHostname(ctx)
	case agent.FieldVersion:
		return m.OldVersion(ctx)
	case agent.FieldStatus:
		return m.OldStatus(ctx)
	case agent.FieldLastSeen:
		return m.OldLastSeen(ctx)
	case agent.FieldRegisteredAt:
		return m.OldRegisteredAt(ctx)
	case agent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case agent.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case agent.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case agent.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	case agent.FieldRegisteredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisteredAt(v)
		return nil
	case agent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldHostname:
		m.ResetHostname()
		return nil
	case agent.FieldVersion:
		m.ResetVersion()
		return nil
	case agent.FieldStatus:
		m.ResetStatus()
		return nil
	case agent.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	case agent.FieldRegisteredAt:
		m.ResetRegisteredAt()
		return nil
	case agent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Agent edge %s", name)
}

// IPChangeMutation represents an operation that mutates the IPChange nodes in the graph.
type IPChangeMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	agent_id       *string
	interface_name *string
	version        *string
	is_external    *bool
	old_addrs      *map[string]interface{}
	new_addrs      *map[string]interface{}
	action         *string
	reason         *string
	timestamp      *time.Time
	created_at     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*IPChange, error)
	predicates     []predicate.IPChange
}

var _ ent.Mutation = (*IPChangeMutation)(nil)

// ipchangeOption allows management of the mutation configuration using functional options.
type ipchangeOption func(*IPChangeMutation)

// newIPChangeMutation creates new mutation for the IPChange entity.
func newIPChangeMutation(c config, op Op, opts ...ipchangeOption) *IPChangeMutation {
	m := &IPChangeMutation{
		config:        c,
		op:            op,
		typ:           TypeIPChange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIPChangeID sets the ID field of the mutation.
func withIPChangeID(id int64) ipchangeOption {
	return func(m *IPChangeMutation) {
		var (
			err   error
			once  sync.Once
			value *IPChange
		)
		m.oldValue = func(ctx context.Context) (*IPChange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IPChange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIPChange sets the old IPChange of the mutation.
func withIPChange(node *IPChange) ipchangeOption {
	return func(m *IPChangeMutation) {
		m.oldValue = func(context.Context) (*IPChange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IPChangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IPChangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IPChange entities.
func (m *IPChangeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IPChangeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IPChangeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IPChange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAgentID sets the "agent_id" field.
func (m *IPChangeMutation) SetAgentID(s string) {
	m.agent_id = &s
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *IPChangeMutation) AgentID() (r string, exists bool) {
	v := m.agent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the IPChange entity.
// If the IPChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPChangeMutation) OldAgentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *IPChangeMutation) ResetAgentID() {
	m.agent_id = nil
}

// SetInterfaceName sets the "interface_name" field.
func (m *IPChangeMutation) SetInterfaceName(s string) {
	m.interface_name = &s
}

// InterfaceName returns the value of the "interface_name" field in the mutation.
func (m *IPChangeMutation) InterfaceName() (r string, exists bool) {
	v := m.interface_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceName returns the old "interface_name" field's value of the IPChange entity.
// If the IPChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPChangeMutation) OldInterfaceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterfaceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterfaceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceName: %w", err)
	}
	return oldValue.InterfaceName, nil
}

// ClearInterfaceName clears the value of the "interface_name" field.
func (m *IPChangeMutation) ClearInterfaceName() {
	m.interface_name = nil
	m.clearedFields[ipchange.FieldInterfaceName] = struct{}{}
}

// InterfaceNameCleared returns if the "interface_name" field was cleared in this mutation.
func (m *IPChangeMutation) InterfaceNameCleared() bool {
	_, ok := m.clearedFields[ipchange.FieldInterfaceName]
	return ok
}

// ResetInterfaceName resets all changes to the "interface_name" field.
func (m *IPChangeMutation) ResetInterfaceName() {
	m.interface_name = nil
	delete(m.clearedFields, ipchange.FieldInterfaceName)
}

// SetVersion sets the "version" field.
func (m *IPChangeMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *IPChangeMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the IPChange entity.
// If the IPChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPChangeMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *IPChangeMutation) ResetVersion() {
	m.version = nil
}

// SetIsExternal sets the "is_external" field.
func (m *IPChangeMutation) SetIsExternal(b bool) {
	m.is_external = &b
}

// IsExternal returns the value of the "is_external" field in the mutation.
func (m *IPChangeMutation) IsExternal() (r bool, exists bool) {
	v := m.is_external
	if v == nil {
		return
	}
	return *v, true
}

// OldIsExternal returns the old "is_external" field's value of the IPChange entity.
// If the IPChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPChangeMutation) OldIsExternal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsExternal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsExternal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsExternal: %w", err)
	}
	return oldValue.IsExternal, nil
}

// ResetIsExternal resets all changes to the "is_external" field.
func (m *IPChangeMutation) ResetIsExternal() {
	m.is_external = nil
}

// SetOldAddrs sets the "old_addrs" field.
func (m *IPChangeMutation) SetOldAddrs(value map[string]interface{}) {
	m.old_addrs = &value
}

// OldAddrs returns the value of the "old_addrs" field in the mutation.
func (m *IPChangeMutation) OldAddrs() (r map[string]interface{}, exists bool) {
	v := m.old_addrs
	if v == nil {
		return
	}
	return *v, true
}

// OldOldAddrs returns the old "old_addrs" field's value of the IPChange entity.
// If the IPChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPChangeMutation) OldOldAddrs(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOldAddrs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOldAddrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldAddrs: %w", err)
	}
	return oldValue.OldAddrs, nil
}

// ClearOldAddrs clears the value of the "old_addrs" field.
func (m *IPChangeMutation) ClearOldAddrs() {
	m.old_addrs = nil
	m.clearedFields[ipchange.FieldOldAddrs] = struct{}{}
}

// OldAddrsCleared returns if the "old_addrs" field was cleared in this mutation.
func (m *IPChangeMutation) OldAddrsCleared() bool {
	_, ok := m.clearedFields[ipchange.FieldOldAddrs]
	return ok
}

// ResetOldAddrs resets all changes to the "old_addrs" field.
func (m *IPChangeMutation) ResetOldAddrs() {
	m.old_addrs = nil
	delete(m.clearedFields, ipchange.FieldOldAddrs)
}

// SetNewAddrs sets the "new_addrs" field.
func (m *IPChangeMutation) SetNewAddrs(value map[string]interface{}) {
	m.new_addrs = &value
}

// NewAddrs returns the value of the "new_addrs" field in the mutation.
func (m *IPChangeMutation) NewAddrs() (r map[string]interface{}, exists bool) {
	v := m.new_addrs
	if v == nil {
		return
	}
	return *v, true
}

// OldNewAddrs returns the old "new_addrs" field's value of the IPChange entity.
// If the IPChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPChangeMutation) OldNewAddrs(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewAddrs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewAddrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewAddrs: %w", err)
	}
	return oldValue.NewAddrs, nil
}

// ClearNewAddrs clears the value of the "new_addrs" field.
func (m *IPChangeMutation) ClearNewAddrs() {
	m.new_addrs = nil
	m.clearedFields[ipchange.FieldNewAddrs] = struct{}{}
}

// NewAddrsCleared returns if the "new_addrs" field was cleared in this mutation.
func (m *IPChangeMutation) NewAddrsCleared() bool {
	_, ok := m.clearedFields[ipchange.FieldNewAddrs]
	return ok
}

// ResetNewAddrs resets all changes to the "new_addrs" field.
func (m *IPChangeMutation) ResetNewAddrs() {
	m.new_addrs = nil
	delete(m.clearedFields, ipchange.FieldNewAddrs)
}

// SetAction sets the "action" field.
func (m *IPChangeMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *IPChangeMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the IPChange entity.
// If the IPChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPChangeMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *IPChangeMutation) ResetAction() {
	m.action = nil
}

// SetReason sets the "reason" field.
func (m *IPChangeMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *IPChangeMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the IPChange entity.
// If the IPChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPChangeMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *IPChangeMutation) ResetReason() {
	m.reason = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *IPChangeMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *IPChangeMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the IPChange entity.
// If the IPChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPChangeMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *IPChangeMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IPChangeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IPChangeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IPChange entity.
// If the IPChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPChangeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IPChangeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the IPChangeMutation builder.
func (m *IPChangeMutation) Where(ps ...predicate.IPChange) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IPChangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IPChangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IPChange, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IPChangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IPChangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IPChange).
func (m *IPChangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IPChangeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.agent_id != nil {
		fields = append(fields, ipchange.FieldAgentID)
	}
	if m.interface_name != nil {
		fields = append(fields, ipchange.FieldInterfaceName)
	}
	if m.version != nil {
		fields = append(fields, ipchange.FieldVersion)
	}
	if m.is_external != nil {
		fields = append(fields, ipchange.FieldIsExternal)
	}
	if m.old_addrs != nil {
		fields = append(fields, ipchange.FieldOldAddrs)
	}
	if m.new_addrs != nil {
		fields = append(fields, ipchange.FieldNewAddrs)
	}
	if m.action != nil {
		fields = append(fields, ipchange.FieldAction)
	}
	if m.reason != nil {
		fields = append(fields, ipchange.FieldReason)
	}
	if m.timestamp != nil {
		fields = append(fields, ipchange.FieldTimestamp)
	}
	if m.created_at != nil {
		fields = append(fields, ipchange.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IPChangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ipchange.FieldAgentID:
		return m.AgentID()
	case ipchange.FieldInterfaceName:
		return m.InterfaceName()
	case ipchange.FieldVersion:
		return m.Version()
	case ipchange.FieldIsExternal:
		return m.IsExternal()
	case ipchange.FieldOldAddrs:
		return m.OldAddrs()
	case ipchange.FieldNewAddrs:
		return m.NewAddrs()
	case ipchange.FieldAction:
		return m.Action()
	case ipchange.FieldReason:
		return m.Reason()
	case ipchange.FieldTimestamp:
		return m.Timestamp()
	case ipchange.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IPChangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ipchange.FieldAgentID:
		return m.OldAgentID(ctx)
	case ipchange.FieldInterfaceName:
		return m.OldInterfaceName(ctx)
	case ipchange.FieldVersion:
		return m.OldVersion(ctx)
	case ipchange.FieldIsExternal:
		return m.OldIsExternal(ctx)
	case ipchange.FieldOldAddrs:
		return m.OldOldAddrs(ctx)
	case ipchange.FieldNewAddrs:
		return m.OldNewAddrs(ctx)
	case ipchange.FieldAction:
		return m.OldAction(ctx)
	case ipchange.FieldReason:
		return m.OldReason(ctx)
	case ipchange.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case ipchange.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IPChange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPChangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ipchange.FieldAgentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case ipchange.FieldInterfaceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceName(v)
		return nil
	case ipchange.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case ipchange.FieldIsExternal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsExternal(v)
		return nil
	case ipchange.FieldOldAddrs:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldAddrs(v)
		return nil
	case ipchange.FieldNewAddrs:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewAddrs(v)
		return nil
	case ipchange.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case ipchange.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case ipchange.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case ipchange.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IPChange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IPChangeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IPChangeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPChangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IPChange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IPChangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ipchange.FieldInterfaceName) {
		fields = append(fields, ipchange.FieldInterfaceName)
	}
	if m.FieldCleared(ipchange.FieldOldAddrs) {
		fields = append(fields, ipchange.FieldOldAddrs)
	}
	if m.FieldCleared(ipchange.FieldNewAddrs) {
		fields = append(fields, ipchange.FieldNewAddrs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IPChangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IPChangeMutation) ClearField(name string) error {
	switch name {
	case ipchange.FieldInterfaceName:
		m.ClearInterfaceName()
		return nil
	case ipchange.FieldOldAddrs:
		m.ClearOldAddrs()
		return nil
	case ipchange.FieldNewAddrs:
		m.ClearNewAddrs()
		return nil
	}
	return fmt.Errorf("unknown IPChange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IPChangeMutation) ResetField(name string) error {
	switch name {
	case ipchange.FieldAgentID:
		m.ResetAgentID()
		return nil
	case ipchange.FieldInterfaceName:
		m.ResetInterfaceName()
		return nil
	case ipchange.FieldVersion:
		m.ResetVersion()
		return nil
	case ipchange.FieldIsExternal:
		m.ResetIsExternal()
		return nil
	case ipchange.FieldOldAddrs:
		m.ResetOldAddrs()
		return nil
	case ipchange.FieldNewAddrs:
		m.ResetNewAddrs()
		return nil
	case ipchange.FieldAction:
		m.ResetAction()
		return nil
	case ipchange.FieldReason:
		m.ResetReason()
		return nil
	case ipchange.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case ipchange.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown IPChange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IPChangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IPChangeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IPChangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IPChangeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IPChangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IPChangeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IPChangeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IPChange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IPChangeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IPChange edge %s", name)
}

// MetricMutation represents an operation that mutates the Metric nodes in the graph.
type MetricMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	agent_id      *string
	timestamp     *time.Time
	collected_at  *time.Time
	reported_at   *time.Time
	data          *map[string]interface{}
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Metric, error)
	predicates    []predicate.Metric
}

var _ ent.Mutation = (*MetricMutation)(nil)

// metricOption allows management of the mutation configuration using functional options.
type metricOption func(*MetricMutation)

// newMetricMutation creates new mutation for the Metric entity.
func newMetricMutation(c config, op Op, opts ...metricOption) *MetricMutation {
	m := &MetricMutation{
		config:        c,
		op:            op,
		typ:           TypeMetric,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetricID sets the ID field of the mutation.
func withMetricID(id int64) metricOption {
	return func(m *MetricMutation) {
		var (
			err   error
			once  sync.Once
			value *Metric
		)
		m.oldValue = func(ctx context.Context) (*Metric, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metric.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetric sets the old Metric of the mutation.
func withMetric(node *Metric) metricOption {
	return func(m *MetricMutation) {
		m.oldValue = func(context.Context) (*Metric, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetricMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetricMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Metric entities.
func (m *MetricMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetricMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetricMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Metric.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAgentID sets the "agent_id" field.
func (m *MetricMutation) SetAgentID(s string) {
	m.agent_id = &s
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *MetricMutation) AgentID() (r string, exists bool) {
	v := m.agent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldAgentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *MetricMutation) ResetAgentID() {
	m.agent_id = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *MetricMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *MetricMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *MetricMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetCollectedAt sets the "collected_at" field.
func (m *MetricMutation) SetCollectedAt(t time.Time) {
	m.collected_at = &t
}

// CollectedAt returns the value of the "collected_at" field in the mutation.
func (m *MetricMutation) CollectedAt() (r time.Time, exists bool) {
	v := m.collected_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectedAt returns the old "collected_at" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldCollectedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectedAt: %w", err)
	}
	return oldValue.CollectedAt, nil
}

// ResetCollectedAt resets all changes to the "collected_at" field.
func (m *MetricMutation) ResetCollectedAt() {
	m.collected_at = nil
}

// SetReportedAt sets the "reported_at" field.
func (m *MetricMutation) SetReportedAt(t time.Time) {
	m.reported_at = &t
}

// ReportedAt returns the value of the "reported_at" field in the mutation.
func (m *MetricMutation) ReportedAt() (r time.Time, exists bool) {
	v := m.reported_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReportedAt returns the old "reported_at" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldReportedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportedAt: %w", err)
	}
	return oldValue.ReportedAt, nil
}

// ResetReportedAt resets all changes to the "reported_at" field.
func (m *MetricMutation) ResetReportedAt() {
	m.reported_at = nil
}

// SetData sets the "data" field.
func (m *MetricMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *MetricMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *MetricMutation) ResetData() {
	m.data = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MetricMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetricMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Metric entity.
// If the Metric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetricMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetricMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the MetricMutation builder.
func (m *MetricMutation) Where(ps ...predicate.Metric) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetricMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetricMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Metric, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetricMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetricMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Metric).
func (m *MetricMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetricMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.agent_id != nil {
		fields = append(fields, metric.FieldAgentID)
	}
	if m.timestamp != nil {
		fields = append(fields, metric.FieldTimestamp)
	}
	if m.collected_at != nil {
		fields = append(fields, metric.FieldCollectedAt)
	}
	if m.reported_at != nil {
		fields = append(fields, metric.FieldReportedAt)
	}
	if m.data != nil {
		fields = append(fields, metric.FieldData)
	}
	if m.created_at != nil {
		fields = append(fields, metric.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetricMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metric.FieldAgentID:
		return m.AgentID()
	case metric.FieldTimestamp:
		return m.Timestamp()
	case metric.FieldCollectedAt:
		return m.CollectedAt()
	case metric.FieldReportedAt:
		return m.ReportedAt()
	case metric.FieldData:
		return m.Data()
	case metric.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetricMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metric.FieldAgentID:
		return m.OldAgentID(ctx)
	case metric.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case metric.FieldCollectedAt:
		return m.OldCollectedAt(ctx)
	case metric.FieldReportedAt:
		return m.OldReportedAt(ctx)
	case metric.FieldData:
		return m.OldData(ctx)
	case metric.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Metric field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metric.FieldAgentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case metric.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case metric.FieldCollectedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectedAt(v)
		return nil
	case metric.FieldReportedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportedAt(v)
		return nil
	case metric.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case metric.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Metric field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetricMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetricMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Metric numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetricMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetricMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetricMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Metric nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetricMutation) ResetField(name string) error {
	switch name {
	case metric.FieldAgentID:
		m.ResetAgentID()
		return nil
	case metric.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case metric.FieldCollectedAt:
		m.ResetCollectedAt()
		return nil
	case metric.FieldReportedAt:
		m.ResetReportedAt()
		return nil
	case metric.FieldData:
		m.ResetData()
		return nil
	case metric.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Metric field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetricMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetricMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetricMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetricMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetricMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetricMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetricMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Metric unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetricMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Metric edge %s", name)
}
